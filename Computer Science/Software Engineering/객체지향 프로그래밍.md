### 객체 지향 프로그래밍 ###
___
- 보통 OOP라고 많이 부른다.

#### 객체지향 프로그래밍의 역사 ####
___
1. 순차적, 비구조적 프로그래밍(필요한게 있으면, 계속 순서대로 추가해가며 구현하는 방식, 점점 규모가 커지게 되면 나중에 코드가 어떻게 연결되어 있는지 확인조차 어려워진다.) -> 절차적, 구조적 프로그래밍(반복될 가능성이 있는 것들을 재사용이 가능한 함수(프로시저)로 만들어 사용하는 프로그래밍 방식, but 너무 추상적)-> 이를 한번에 묶기 위한 패러다임이 **객체지향 프로그래밍**이다.

2. 특정한 개념의 함수와 자료형을 함께 묶어서 관리하기 위해 나온 것

3. 객체 내부에 자료형(필드)와 함수(메소드)가 같이 존재하는 것
___
#### 객체지향 프로그래밍의 특징 ####
___
1. **추상화**: 필요로 하는 속성이나 행동을 추출하는 작업, 세부적인 사물들의 공통적인 특징을 파악한 후 하나의 집합으로 만들어 내는 것으로, 추상화로 구현해두면 다른 곳의 코드는 수정할 필요 없이 추가로 만들 부분만 새로 생성해주면 된다.

2. **캡슐화**: 낮은 결합도를 유지할 수 있도록 설계하는 것으로, 쉽게 말하면 한 곳에서 변화가 일어나도 다른 곳에 미치는 영향을 최소화 시키는 것을 말한다.
- 결합도란? 어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인가를 나타내는 말이다. 즉 독립적으로 만들어진 객체들 간의 의존도가 최대한 낮게 만드는 것이 중요하다.

3. **상속**: 여러 개체들이 지닌 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립하는 과정이며, 자식 클래스를 외부로부터 은닉하는 캡슐화의 일종이라고 말할 수 있다.

4. **다형성**: 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력을 뜻하며, 객체 지향의 **핵심**과도 같은 부분이다. 즉, 부모 클래스의 메소드를 자식 클래스가 오버라이딩해서 자신의 역할에 맞게 활용하는 것이 다향성이다.

___
#### 객체 지향 설계 과정 ####
____
1. 제공해야 할 기능을 찾고 세분화한다. 그리고 그 기능을 알맞은 객체에 할당한다.

2. 기능을 구현하는데 필요한 데이터를 객체에 추가한다.

3. 그 데이터를 이용하는 기능을 넣는다.

4. 기능은 최대한 캡슐화하여 구현한다.

5. 객체 간에 어떻게 메소드 요청을 주고 받을지 결정한다.

____
#### 객체 지향 설계 원칙 ####

____
1. SOLID라고 부르는 5가지 설계 원칙이 존재한다.

2.  **SRP(Single Responsibility)**: 단일 책임 원칙
- 클래스는 단 한 개의 책임을 가져야 한다.
- 클래스를 변경하는 이유는 단 한개여야 한다.

3. **OCP(Open-Closed)**: 개방-폐쇄 원칙
- 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
- 기능을 변경하거나 확장할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않는다.

4. **LSP(Liskov Substitution)**: 리스코프 치환 법칙
- 상위 타입의 객체를 하위 타입의 객체로 치환해도, 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
- 상속 관계가 아닌 클래스들을 상속 관계로 설정하면, 이 원칙이 위배된다.

5. **ISP(Interface Segregation)**: 인터페이스 분리 원칙
- 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
- 각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써, 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 한다.

6. **DIP(Dependency Inversion)**: 의존 역전 원칙
- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다.
- 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.
- 즉, 저수준 모듈이 변경돼도 고수준 모듈은 변경할 필요가 없다는 것이다. 